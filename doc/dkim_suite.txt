Found this floating around online, although I don't think it was ever implemented.  Useful reference.

DKIM Validation Suite - Test Plan
#################################

The DKIM validation suite is backed by a comprehensive interoperability
test plan.  The test plan is composed of two categories of test cases:
tests pulled directly from a close reading of RFC 4871, and tests
generated by the DKIM interoperability community.

Test Case Overview
==================

Validation tests are broken down into the following categories:

    - Canonicalization
    - Signature
    - Public Key
    - Tags
        - Generic
        - Signatures
        - Public Key Record
    - Signing/Verifying Algorithm
    - System

Canonicalization Tests
======================

Canonicalization is the act of preparing a message for signing or
verifiation.

* Verifiers must implement 'simple' and 'relaxed' canonicalization (3.4)
* Default canonicalization algorithm is 'simple' (3.4)
* Verifiers must ignore signaturess that use unrecognized canonicalization algorithms (3.4)
* 'simple' header canonicalization (3.4.1)
* 'relaxed' header canonicalization (3.4.2)
* 'simple' body canonicalization (3.4.3)
* 'relaxed' body canonicalization (3.4.4)
* Body length limits (3.4.5)
    - Optional octet measure
    - Not specified means "entire message body signed"
    - Length is calculated after canonicalization
* Message/canonicalization tests (interop)
    - header only, no body
    - header followed by 1 through 3 CRLFs
    - header followed by 1-3 CRLFs, body followed by 0-3 extra CRLFs
* WSP injection (interop)
    - headers
    - DKIM signature
    - within b=

Signature Tests
===============

* DKIM-Signature Header Field (3.5)
    - test syntax error
* Header fields are canonicalized in order of signature's header list (3.7)
    - test reordering of headers
* Multiple signature considerations (4.1)
    - future signature + existing signature
        - what makes signatures "future"
    - strict signature + relaxed signature
    - origination signature + forwarder signature
    - "i=" differentiated signatures
* Headers to sign (5.4)
    - From: must be signed
    - Return-Path: must not be signed
    - "Date, Subject, Reply-To, Sender, MIME headers" are highly advised
    - h= must not include DKIM-sig, except to indicate other (preexisting) DKIM sigs
    - use "number of existing header plus 1" to prohibit additional headers
    - signers must sign the last header if multiple headers are present
    - should not be included: return-path, received, comments, keywords, bcc, resent-bcc, dkim-sig
    - test repeated headers
    - test inclusion of absent header
    - test additional unsigned headers
* Signature header field validation (6.1.1)

Public Key Tests
================

* Support for future lookup algorithms (3.6) (see also 3.5 "q=")
* DNS namespace (3.6.2.1)
    - wildcarding does not make sense (eg, "s=*" or "d=*")
* DNS TXT records and WSP (3.6.2.2)
* Getting a public key (6.1.2)
    - public key query failure, "TEMPFAIL (key unavailable)" or 451 code
    - if no public key exists, "PERFAIL (no key for signature)"
    - multiple returned keys, skip to next if possible:
        - if key format does not adhere to spec, skip or PERMFAIL (key syntax error)
        - if "g=" != "i=", skip or PERMFAIL (inapplicable key)
        - if no local part of "i=", "g=" must be "g=*" or "omitted g=", skip or PERMFAIL (inapplicable key)
        - if public-key-record-"h=" != sig-"a=", skip or PERMFAIL (inappropriate hash algorithm)
        - if "p=" is empty, skip or PERMFAIL (key revoked)
        - if key data is not suitable given sigs's "a=" and "k=", skip or PERMFAIL (inappropriate key algorithm)

Tag Tests
=========

Tags are the way DKIM represents key-value pairs.  The tag mechanism is
shared across signatures and public key records.  However, signatures
and public key records maintain their own separate lists of tags.

Generic Tag Tests
-----------------

Generic raw parsing tests:

* tag-list = tag-spec 0*( ";" tag-spec ) [ ";" ] (3.2)
    - test for optional ";" at end of tag-list
* tag-spec = [FWS] tag-name [FWS] "=" [FWS] tag-value [FWS] (3.2)
    - test for optional presence of FWS at allowed places
* tag-name = ALPHA 0*ALNUMPUNC (3.2)
    - test for well-formed-but-bogus tags (eg, "t1=" or "z_a=")
    - test for badly-formed tags (eg, "9=" or "_=")
* tag-value = [ tval 0*( 1*(WSP / FWS) tval ) ] (3.2)
    - test for entire value as optional
    - test for WSP between "=" and ";" (eg, "t=  ;")
    - test for random WSP injection across value
    - test for bad values (eg, "%x20" or "%x3B")

Specific tags are further constrained:

* "plain text" (including UTF8-encoded (3.2))
* "base64"
* "qp-section"
* "dkim-quoted-printable" (2.6)

Each tag is exercised along the following lines:

* Tags are case sensitive (3.2)
* Test absence of each tag
* Empty-value tags != default tags (3.2)
* Default tag values may be included (optional for legibility) (3.2)
* WSP inside value is significant (3.2)
* WSP within value must be retained (unless tag excludes) (3.2)

* Unrecognized tags must be ignored (3.2)
* Unrecognized tags must be included in hash calculation
* No duplicate tags allowed (3.2)

Signature Tag Tests
-------------------

* v, version (required)
    - type: "1"
    - value: must be "1"
    - tests:
        - "1" != "1.0"

* a, algorithm (required)
    - type: plain-text
    - value: "rsa-sha1" or "rsa-sha256"
    - tests:
        - no WSP in value
        - future extension: "a123" is valid and unrecognized

* b, signature data (required)
    - type: base64
    - value: signature data
    - tests:
        - WSP ignored in value
        - bad syntax
        - wrong checksum
        - relaxed+"; after b"
        - relaxed+"stuff after b"
        - "b=" treated as empty

* bh, hash of canonicalized body (required)
    - type: base64
    - value: hash of canonicalized body limited by "l="
    - tests:
        - WSP ignored in value
        - bad syntax
        - wrong checksum

* c, canonicalization (optional)
    - type: plain-text
    - value: {simple,relaxed,unknown}/{simple,implicit-simple,relaxed,unknown}
    - default: "simple/simple"
    - tests:
        - if "single-value", "single-value/simple" is assumed
        - invalid "unknown" (eg "123-45")
        - valid "uknown" (eg "abc-def")
        - all combinations of value

* d, domain (required)
    - type: plaint-text
    - value: domain-name
    - tests:
        - must be same as or parent of "i="
        - internationalized domain names must be encoded (RFC3490)

* h, header fields (required)
    - type: plain-text
    - value: header list
    - tests:
        - must not include DKIM-sig header itself
        - FWS is allowed around ":" separator
        - case-insensitive header field comparison
        - must not be empty
        - non-existant headers are OK

* i, identity (optional)
    - type: dkim-quoted-printable
    - value: email address with optional local-part
    - default: "@<d=>"
    - tests:
        - domain part of "i=" must be same or subdomain of "d="
        - internationalized domain names must be converted according to rfc3490
            - empty-local-part encoded
            - decode error
            - empty local syntax error
        - "i=" != "d="
        - FWS everywhere

* l, body length (optional)
    - type: plaint-text
    - value: unsigned decimal integer
    - default: entire body
    - tests:
        - must not be greater than # of octets in canonicalized msg body
        - 76 decimal digit constraint
        - l=0, body is unsigned
        - missing data invalidates bh
        - present extra data does not invalidate bh

* q, query-methods (optional)
    - type: plain-text
    - value: colon-separated list of query methods (of form "type[/options]")
    - default: "dns/txt"
    - tests:
        - "dns/txt:dns/bogus" should be valid (1st one works)
        - "dns/bogus:dns/txt" should be valid (1st one skipped, 2nd one works)
        - "dns" is bogus, must be "dns/txt"
        - DNS TXT present
        - multiple methods
        - unsupported/future extension

* s, selector (required)
    - type: plain-text
    - value: sub-domain

* t, timestamp at msg creation time (optional)
    - type: plain-text
    - value: unsigned decimal integer (# seconds since jan 1, 1970)
    - default: unknown creation time
    - tests:
        - accepts 12 digits

* x, sig expiration (optional)
    - type: plain-text
    - value: unsigned decimal integer (# seconds since jan 1, 1970)
    - default: no expiration
    - tests:
        - x= must be greater than t=
        - what if x= and no t=?
        - "missing equals never expires"
        - not expired
        - expired
        - syntax error

* z, copied header fields (optional)
    - type: dkim-quoted-printable
    - value: vertical-bar-separated list of selected headers (header & value)
    - default: null
    - tests:
        - header field must encode the vertical bar
        - all WSP must be encoded
        - encoded FWS can be added, but must be removed before decoding

* Verifiers must ignore sigs w/ bad "v=" tags [PERMFAIL - incompatible version]
* Verifiers must ignore sign w/o required tags [PERMFAIL - signature missing required tag]
* If "i=" is absent, "i=" is effectively domain portion of "d="
* If d= and i= mismatch, ignore sig [PERMFAIL - domain mismatch]
* If h= doesn't include From:, [PERMFAIL - From field not signed]
* If x= is expired, maybe [PERMFAIL - field signature expired]
* Ignore sig if unacceptable d= value (eg, "com" or "co.uk")
* May ignore sig for any reason [PERMFAIL - unacceptable signature header]

Public Key Record Tag Tests
---------------------------

* v, version of DKIM key record (optional)
    - type: plain-text
    - value: "DKIM1"
    - default: "DKIM1"
    - tests:
        - must be first tag of record
        - "DKIM1" != "DKIM1.0"
        - empty-not-usable
        - other-not-used
        - other-discarded
        - multiple keys

* g, granularity (optional)
    - type: plain-text
    - value: local part of email address
    - default: "*"
    - tests:
        - value must be local part of signature-"i=", or empty string if "i=" is absent
        - empty "g=" never matches any address
        - present-match
        - present-not-match
        - missing-matches-all
        - missing-matches-empty-local
        - star
        - empty-matches-nothing
        - empty-does-not-match-empty-string
        - invalid pattern

* h, hash algorithms (optional)
    - type: plain-text
    - value: colon-separated list of hash algorithms
    - default: allow all algorithms
    - tests:
        - "sha256" must be supported by verifiers and signers
        - "sha1" must be supported by verifiers
        - future extension support
        - missing-accepts-all
        - unacceptable

* k, key type (optional)
    - type: plain-text
    - value: hyphenated-word
    - default: "rsa"
    - tests:
        - must support this
        - future

* n, notes (optional)
    - type: qp-section
    - value: short notes of interest to humans
    - default: empty
    - tests:
        - ignored

* p, public-key data (required)
    - type: base64
    - value: key data
    - tests:
        - empty value means revoked
        - WSP allowed at arbitrary places
            - CRLFs must be followed by 1+ WSP character
        - bad base64
        - bad key

* s, service type (optional)
    - type: plain-text
    - value: colon-separated list of service types
    - default: "*"
    - tests:
        - future use
        - missing-matches-all
        - star
        - star-among-others
        - email
        - not-email
        - empty-is-not-usable
        - not-email-causes-skip

* t, flags (optional)
    - type: plain-text
    - value: colon-separated list of names
        - "y", testing
        - "s", sig-"i="'s domain must equal sig-"d=" (NOT subdomain)
    - default: no-flags-set
    - tests:
        - strict-not-subdomain
        - strict-subdomain

Signing/Verifying Algorithm Tests
=================================

* Headers always signed from bottom up (4.2)
* Verification (6.1.3)
    - header field names vs entries in "h=" must be case-insensitive
    - body hash failure, PERMFAIL (body hash did not verify)
    - header hash failure, PERMFAIL (signature did not verify)
    - if body length does not cover entire message, maybe PERMFAIL (unsigned content)
* Verifiers must support rsa-sha1 and rsa-sha256 (256 is default) (3.3)
* Signers must do 256 and should do 256 (3.3)
* Verifiers must support 512-2048 bit keys (3.3.3)
* Verifiers must ignore algorithms that are not implemented (3.3.3)

System Tests
============

* Parent domain signing constraints (3.8)
    - key-record contains "t=s":
        - "i=" == "d=" is OK
        - "i=" != "d=" fails
* Multiple signatures should be evaluated independently (4.2)
* Limit number of signatures to verify (4.2)
* Message normalization, 8-bit to 7-bit before signing (5.3)
* Multiple signatures (interop)
    - multiple valid sigs
    - bad sig mixed into middle of valid sigs
* Meta message tests (interop)
    - From
    - Sender
    - Resent-From
    - Resent-Sender
    - Unsigned resent headers ignored
    - unsigned header
    - i missing multiple match?
    - i empty-local-part multiple matches
    - signature i single match
    - signed header doesn't match identity
    - subdomain-addr doesn't match
    - no headers match identity
    - syntax err in address
    - multiple From addresses
